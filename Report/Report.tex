\documentclass[]{article}
\usepackage[table,xcdraw,svgnames]{xcolor}
\usepackage{commons/course}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\begin{document}
	
\begin{titlepage}
\begin{center}
\heading
\end{center}
\end{titlepage}
%%% title pages


%%% header of pages
\newpage
\pageheader
\tableofcontents

\newpage

 \Large \textbf{}
%%%
\begin{section-container}{شرح وظایف}
\end{section-container}


\pagebreak



\begin{section-container}{مقدمه}
	
	\subsection{تعریف الگوریتم}
	الگوریتم مورد استفاده الگوریتم ضرب ماتریسی \lr{Cannon} می‌باشد در این الگوریتم با تقسیم کردن ماتریس‌های ورودی و خروجی به بلاک‌های $k*k$ که در آن $k$ عدد ثابتی می‌باشد می‌خواهیم با داشتن تعدادی پردازنده‌ که به صورت موازی کار می‌کنند عملیات ضرب ماتریسی را بهبود ببخشیم. به طور مثال ماتریس‌ها زیر را در نظر بگیرید:
	\begin{equation}
	A = \begin{bmatrix}
	A_{11}& A_{12}& \dots A_{1\mu}\\
	\vdots& \ddots& \vdots\\
	A_{\lambda1}& A_{\lambda2}& \dots A_{\lambda\mu}\\
	\end{bmatrix} 
	\ \ \, 
	B = \begin{bmatrix}
	B_{11}& B_{12}& \dots B_{1\gamma}\\
	\vdots& \ddots& \vdots\\
	B_{\mu1}& B_{\mu2}& \dots B_{\mu\gamma}\\
	\end{bmatrix} 
	\end{equation}
	
	که در آن هر $A_{ij} و B_{ij}$ یک بلاک $k*k$ می‌باشد.(توجه می‌کنیم که  سایز‌ ماتریس‌ها اگر بخش‌‌پذیر به $k$ نباشد با اضافه‌ کردن صفر آن را بخش پذیر می‌کنیم) با این اوصاف طبق قاعده‌ی ضرب بلوکی می‌دانیم که بلاک $C_{ij}$ در ماتریس جواب از رابطه‌ی زیر محاسبه می‌شود.
	\begin{equation}
	C_{ij} = \sum_{x=0}^\mu A_{ix}B_{xj}
	\label{1}
	\end{equation}
	
	با داشتن تعداد تعداد مشخصی ضرب کننده‌ی ماتریسی $k*k$ می‌توانیم این به طور موازی با استفاده از آنها حاصل نهایی $A\times B$ را محاسبه کنیم. 
	\pagebreak
	
\subsection{قرارداد‌های ریاضی}

توجه می‌کنیم که در ادامه‌ی این گزارش و توضیحات لازمه در نظر می‌گیریم که ماتریس‌های ورودی $A_{mr}$ و $B_{rn}$ خواهند بود و بنابراین ماتریس‌ خروجی به صورت
$A_{mr} \times B_{rn} = C_{mn}$
خواهد بود. همچنین لازم است که توجه داشته باشید که وقتی ماتریس‌ها را به فرم بلوکی می‌نویسیم مقادیر زیر را تعریف می‌کنیم:
\begin{subequations}
	\begin{equation}
		\mu = \ceil*{\dfrac{r}{k}}
	\end{equation}    
	\begin{equation}
		\lambda = \ceil*{\dfrac{m}{k}}
	\end{equation}
	\begin{equation}
	\gamma = \ceil*{\dfrac{n}{k}}
	\end{equation}
	\label{2}
\end{subequations}
از این نماد‌ها به کرّات در طول گزارش استفاده خواهد شد. توجه می‌کنیم که علت اینکه سقف این حاصل تقسیم‌ها را در نظر گرفتیم همان است که اگر اندازه‌ی ماتریس‌ها بر $k$ بخش‌پذیر نباشد با اضافه کردن صفر به انتها‌ی آن باعث بخش‌پذیری می‌شویم. 
\subsection{نحوه‌ی عملکرد از نظر مساحت و تایمینگ}
از آنجایی که هر ضرب کننده‌ی ماتریسی در حدود
 $k^3$
 کلاک سایکل زمان می‌برد و محاسبه‌ی هر بلوک $C_{ij}$ با توجه به
 \autoref{1}
به $\mu$ بار به ضرب ماتریسی نیاز دارد. همچنین برای محاسبه‌ی تمام بلوک‌ها باید $\lambda\gamma$ بار محاسبات بالا را انجام دهیم با این حال اگر فرض کنیم که تعداد پردازنده‌ها $p$ باشد آنگاه می‌توانیم ببینیم که تعداد کلاک‌ سایکل‌ها تقریبا برابر با عبارت زیر است:
\begin{equation}
	\dfrac{\lambda\gamma\mu k^2}{\text{\lr{\#number of PU}}} = 	\dfrac{\lambda\gamma\mu k^2}{p}
\end{equation}
	\pagebreak

\subsection{استاندارد‌ \lr{IEEE 754}}
محاسبات در این پروژه از استاندارد
 \lr{IEEE 754 - Single-precision floating-point}
 پیروی می‌کند که به طور مختصر به شرح آن می‌پردازیم. \\
 در این استاندارد اعداد اعشار با سه بخش \lr{exponent} , \lr{fraction} , \lr{sign} مشخص می‌شوند که سهم هر یک از آنها مانند مثال زیر است:
 
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{source/float_example.png}
\end{figure}

و هر عدد طبق فرمول زیر به این نمایش در می‌آید:

\begin{equation}
\text{value} = (-1)^{sign} \times 2^{(E-127)} \times (1 + \sum_{i=1}^{23}b_{23-i}2^{-i})
\end{equation}
 

\subsection{مراجع مورد استفاده}

\end{section-container}

\begin{section-container}{توصیف معماری سیستم}
\subsection{اینترفیس‌های سیستم و قرارداد استفاده از آن }
به طور کلی سخت‌افزار از یک حافظه و بخش محاسبه‌ی ضرب ماتریسی تشکیل شده است که پردازنده‌ می‌تواند ورودی‌ها را درون حافظه قرار داده و خروجی‌ها را نیز از آن بخواند.
(\lr{I/O Map}). 
با این حال قرارداد‌هایی در نحوه‌ی استفاده از مموری وجود دارد که باید به آن توجه شود. ساختار کلی حافظه به صورت زیر خواهد بود:
\begin{table}[h]
	\centering
	\begin{tabular}{clll}
		\hline
		\multicolumn{4}{|c|}{Config}                                          \\ \hline
		\multicolumn{4}{|c|}{Status}                                          \\ \hline
		\multicolumn{4}{|c|}{$A_{11}$}                                        \\ \hline

		\multicolumn{4}{|c|}{$A_{12}$}                                        \\ \hline

		\multicolumn{4}{|c|}{$\vdots$}                                        \\ \hline
		\multicolumn{4}{|c|}{$A_{\lambda\mu}$}  \\ \hline   
		\multicolumn{4}{|c|}{$B_{11}$}                                        \\ \hline
		\multicolumn{4}{|c|}{$B_{12}$}                                        \\ \hline
				\multicolumn{4}{|c|}{$\vdots$}                                        \\ \hline
		\multicolumn{4}{|c|}{$B_{\mu\gamma}$}                                        \\ \hline
				\multicolumn{4}{|l|}{\cellcolor[HTML]{595959}{\color[HTML]{595959}aaaaaaaaaaaaaaaaaaaaa }} \\ \hline   
			\multicolumn{4}{|c|}{$C_{11}$}                                        \\ \hline
	
	\multicolumn{4}{|c|}{$C_{12}$}                                        \\ \hline
	
	\multicolumn{4}{|c|}{$\vdots$}                                        \\ \hline
	\multicolumn{4}{|c|}{$C_{\lambda\gamma}$}  \\ \hline 
	    				\multicolumn{4}{|l|}{\cellcolor[HTML]{595959}{\color[HTML]{595959}aaaaaaaaaaaaaaaaaaaaa }} \\ \hline   
	\end{tabular}
	\caption{شماتیک حافظه}
\end{table}


که در آن هر یک از $A_{ij} , B_{ij} , C_{ij}$ها یک بلوک $k*k$ خواهند بود و باید آن‌ها را به صورت سطری در خانه‌های پشت سر هم حافظه نوشت. برای مثال اگر ماتریس $A$ به صورت زیر باشد:
$$ A = \begin{bmatrix}
1& 2 & 3\\
4& 5 & 6
\end{bmatrix} $$

و در صورتی که 
$k=2$
و به عبارتی بلوک‌ها $2*2$ باشند \lr{CPU} باید آن را به صورت زیر در حافظه قرار دهد:

\begin{table}[h]
	\centering
	\begin{tabular}{clll}
		\hline
		\multicolumn{4}{|c|}{Config}                                          \\ \hline
		\multicolumn{4}{|c|}{Status}                                          \\ \hline
		\multicolumn{4}{|c|}{1}                                        \\ \hline
		\multicolumn{4}{|c|}{2}                                        \\ \hline
		\multicolumn{4}{|c|}{4}                                        \\ \hline
		\multicolumn{4}{|c|}{5}                                        \\ \hline
		
		\multicolumn{4}{|c|}{3}                                        \\ \hline
				\multicolumn{4}{|c|}{0}                                        \\ \hline
					\multicolumn{4}{|c|}{6}                                        \\ \hline
										\multicolumn{4}{|c|}{0}                                        \\ \hline
				\multicolumn{4}{|c|}{$\vdots$}                                        \\ \hline
		\multicolumn{4}{|l|}{\cellcolor[HTML]{595959}{\color[HTML]{595959}aaaaaaaaaaaaaaaaaaaaa }} \\ \hline   
	\end{tabular}
\end{table}

به عبارتی وظیفه‌ی بلوک کردن ماتریس و همچنین صفر قرار دادن خانه‌های اضافی به عهده‌ی \lr{CPU} خواهد بود. \\ 
همچنین \lr{CPU} باید اولین خانه‌ی حافظه را که مربوط به کانفیگ می‌باشد به صورت زیر از اعداد پر کند:

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|c|}
				\hline
				$\lambda$ & $\gamma$ & $\mu$ & $\theta$ \\ \hline
	\end{tabular}
\end{table}
که هر کدام ۸بیت خواهند بود و مقادیر این پارامتر‌ها در 
\autoref{2}
مشخص شده است و البته باید توجه داشته باشید که مقدار $\theta$ نیز از رابطه‌ی زیر محاسبه می‌شود:
\begin{equation}
	\theta = \dfrac{\lambda\gamma}{\text{\lr{\#Matrix Processors}}}
\end{equation}

همچنین دومین خانه‌ی حافظه که مربوط به \lr{Status} می‌باشد مطابق شکل زیر می‌باشد.

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|c|c|}
		\hline
		\lr{CPU Ready} & \lr{MP Acknowledge} & $\dots$ &\lr{CPU Acknowledge} & \lr{MP Ready}\\ \hline
	\end{tabular}
\end{table}
وظیفه‌ی \lr{CPU} این است که بعد از قرار دادن ورودی‌ها و تنظیم کردن \lr{Config} مقدار بیت \lr{CPU Ready} را فعال کند و بعد از این که بیت \lr{Acknowledge} را از طرف ضرب کننده‌ی ماتریسی دریافت کرد به کارش ادامه دهد بعد از تمام شدن عملیات ماتریسی بیت \lr{MP Ready} فعال می‌شود و \lr{CPU} می‌تواند بلاک‌های ماتریس خروجی را از مکانی که در مموری مربوط به خروجی‌ها می‌باشد استخراج کند.


\subsection{دیاگرام‌های بلوکی سخت‌افزار}
\subsection{توصیف ماجول‌ها}
\subsection{ساختار درختی سیستم}
\end{section-container}

\pagebreak
\section{روند شبیه‌سازی و نتایج حاصل}
\subsection{توصیف \lr{TestBench}ها}
\subsection{توصیف روند کلی شبیه‌سازی}
\subsection{توصیف \lr{Golden Model}}
\subsection{مقایسه‌ی خروجی‌های نهایی با \lr{Golden Model}}



\end{document}







